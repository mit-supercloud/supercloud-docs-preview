<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://supercloud.mit.edu/using-the-system/submitting-jobs/submitting-jobs/" />
      <link rel="shortcut icon" href="../../../img/favicon.ico" />
    <title>Submitting Jobs - SuperCloud Docs</title>
    <link rel="stylesheet" href="../../../css/theme.css" />
    <link rel="stylesheet" href="../../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Submitting Jobs";
        var mkdocs_page_input_path = "using-the-system/submitting-jobs/submitting-jobs.md";
        var mkdocs_page_url = "/using-the-system/submitting-jobs/submitting-jobs/";
      </script>
    
    <script src="../../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../../.." class="icon icon-home"> SuperCloud Docs
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../requesting-account/">Requesting an Account</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../getting-started/">Getting Started</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../systems-and-software/">Systems and Software</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../acknowledging-us/">Acknowledging Us</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Using the System</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="#">Files and Data</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../files-and-data/transferring-files/">Transferring Files</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../files-and-data/shared-groups/">Shared Groups</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../software-packages/">Software and Package Management</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../monitoring-system-and-jobs/">Monintoring System and Job Status</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Submitting Jobs</a>
    <ul class="current">
                <li class="toctree-l2 current"><a class="reference internal current" href="./">Submitting Jobs</a>
    <ul class="current">
    <li class="toctree-l3"><a class="reference internal" href="#how-to-start-an-interactive-job-with-llsub-interactive">How to start an Interactive Job with LLsub {##interactive}</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#submitting-a-simple-serial-batch-job-serial">Submitting a Simple Serial Batch Job {##serial}</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#submitting-with-llsub">Submitting with LLsub</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#submitting-with-slurm-scheduler-commands">Submitting with Slurm Scheduler Commands</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#requesting-additional-resources-with-sbatch-sbatch">Requesting Additional Resources with sbatch {##sbatch}</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#additional-cores-on-multiple-nodes-slurm-dist">Additional Cores on Multiple Nodes {##slurm-dist}</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#additional-cores-on-the-same-node-slurm-shared">Additional Cores on the Same Node {##slurm-shared}</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#job-arrays-slurm-jobarray">Job Arrays {##slurm-jobarray}</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#exclusive-nodes-slurm-exclusive">Exclusive Nodes {##slurm-exclusive}</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#adding-more-memory-or-cores-per-task-slurm-memcores">Adding More Memory or Cores per Task {##slurm-memcores}</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#reqesting-gpus-slurm-gpus">Reqesting GPUs {##slurm-gpus}</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#requesting-additional-resources-with-llsub-llsub">Requesting Additional Resources with LLsub {##llsub}</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#additional-cores-on-the-same-nodeadditional-cores-on-the-same-node-1-llsub-shared">Additional Cores on the Same Node[]{#additional-cores-on-the-same-node-1} {##llsub-shared}</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#job-array-llsub-jobarray">Job Array {##llsub-jobarray}</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#adding-more-memory-or-cores-llsub-memcores">Adding More Memory or Cores {##llsub-memcores}</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#requesting-gpus-llsub-gpus">Requesting GPUs {##llsub-gpus}</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#llmapreduce-llmapreduce">LLMapReduce {##llmapreduce}</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#matlaboctave-tools-matlab">Matlab/Octave Tools {##matlab}</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#pmatlab">pMatlab</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#submitting-with-llsub-or-sbatch">Submitting with LLsub or Sbatch</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#launchfunctionongrid-and-launchparforongrid">LaunchFunctionOnGrid and LaunchParforOnGrid</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#triples-mode-triples">Triples Mode {##triples}</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#llsub">LLsub</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#llmapreduce">LLMapReduce</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#pmatlab_1">pMatlab</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#triples-mode-tuning-tuning">Triples Mode Tuning {##tuning}</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../job-array-triples/">Job Array Triples</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">Best Practices</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../best-practices/filesystem/">Best Practices for using the Filesystem</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../best-practices/gpu-jobs/">Optimizing your GPU Jobs</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../web-portal/">Web Portal</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../databases/">Databases</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../jupyter-notebooks/">Jupyter Notebooks</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Additional Resources</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../../faqs/">Frequently Asked Questions</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../getting-help/">Getting Help</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../glossary/">Glossary</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../..">SuperCloud Docs</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>Using the System &raquo;</li>
          <li>Submitting Jobs &raquo;</li>
      <li>Submitting Jobs</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="submitting-jobs-submitting_jobs">Submitting Jobs {#submitting_jobs}<a class="headerlink" href="#submitting-jobs-submitting_jobs" title="Permanent link"></a></h1>
<p>For most job types, there are two ways to start the job: using the
commands provided by the scheduler, Slurm, or using wrapper command,
LLsub, that we have provided. LLsub creates a scheduler command based on
the arguments you feed it, and will output that command to show you what
it is running. The scheduler commands may provide more flexibility, and
the wrapper commands may be easier to use in some cases and are
scheduler agnostic. We show some of the more commonly used options. More
Slurm options can be seen on the Slurm
<a href="http://slurm.schedmd.com/man_index.html">documentation</a> page, and more
LLsub options can be seen by running <code>LLsub -h</code> at the command line.</p>
<p>There are two main types of jobs that you can run: interactive and batch
jobs. Interactive jobs allow you to run interactively on a compute node
in a shell. Batch jobs, on the other hand, are for running a pre-written
script or executable. Interactive jobs are mainly used for testing,
debugging, and interactive data analysis. Batch jobs are the traditional
jobs you see on an HPC system and should be used when you want to run a
script that doesn\'t require that you interact with it.</p>
<p>On this page we will go over:</p>
<ul>
<li><code>How to start an Interactive Job with LLsub &lt;#interactive&gt;</code>{.interpreted-text
    role="ref"}</li>
<li><code>How to submit a Basic Serial job with LLsub and sbatch &lt;#serial&gt;</code>{.interpreted-text
    role="ref"}</li>
<li><code>How to request more resources with sbatch &lt;#sbatch&gt;</code>{.interpreted-text
    role="ref"}</li>
<li><code>How to request more resources with LLsub &lt;#llsub&gt;</code>{.interpreted-text
    role="ref"}</li>
<li><code>How to submit an LLMapReduce Job &lt;#llmapreduce&gt;</code>{.interpreted-text
    role="ref"}</li>
<li><code>How to submit a job with pMatlab, sbatch, or
    LaunchFunctionOnGrid &lt;#matlab&gt;</code>{.interpreted-text role="ref"}</li>
<li><code>How to get the most performance out of LLsub, LLMapReduce, and
    pMatlab using Triples Mode &lt;#triples&gt;</code>{.interpreted-text role="ref"}</li>
</ul>
<p>You can find examples of several job types in the <a href="https://github.com/llsc-supercloud/teaching-examples">Teaching
Examples</a> github
repository. They are also in the <code>bwedx</code>shared group directory and
anyone with a Supercloud account can copy them to their home directory
and use them as a starting point.</p>
<h2 id="how-to-start-an-interactive-job-with-llsub-interactive">How to start an Interactive Job with LLsub {##interactive}<a class="headerlink" href="#how-to-start-an-interactive-job-with-llsub-interactive" title="Permanent link"></a></h2>
<p>Interactive jobs allow you to run interactively on a compute node in a
shell. Interactive jobs are mainly used for testing, debugging, and
interactive data analysis.</p>
<p>Starting an interactive job with LLsub is very simple. To request a
single core, run at the command line:</p>
<blockquote>
<p><code>LLsub -i</code></p>
</blockquote>
<p>As mentioned earlier on this page, when you run an LLsub command,
you\'ll see the Slurm command that is being run in the background when
you submit the job. Once your interactive job has started, you\'ll see
the command line prompt has changed. It\'ll say something like:</p>
<blockquote>
<p><code>USERNAME@d-14-13-1:~$</code></p>
</blockquote>
<p>Where <code>USERNAME</code> is your username, and <code>d-14-13-1</code> is the hostname of
the machine you are on. This is how you know you are now on a compute
node in an interactive job.</p>
<p>By default you will be allocated a single CPU core. We have a number of
options that allow you to request additional resources. You can always
view these options and more by running <code>LLsub -h</code>. We\'ll go over a few
of those here. Note that these can (and often should) be combined.</p>
<ul>
<li><strong>Full Exclusive Node:</strong> Add the word <code>full</code> to request an exclusive
    node. No one else will be on the machine with you:</li>
</ul>
<pre><code>&lt;!-- --&gt;
</code></pre>
<ul>
<li><strong>A number of cores:</strong> Use the <code>-s</code> option to request a certain
    number of CPU cores, or slots. Here, for example, we are requesting
    4 cores:</li>
</ul>
<pre><code>&lt;!-- --&gt;
</code></pre>
<ul>
<li><strong>GPUs:</strong> Use the <code>-g</code> option to request a GPU. You need to specify
    the GPU type and the number of GPUs you want. You can request up to
    the number of GPUs on a single node. Refer to the
    <code>systems_and_software</code>{.interpreted-text role="ref"} page to see how
    many GPUs are available per node. Remember you may want to also
    allocate some number of CPUs in addition to your GPUs. To get 20
    CPUs and 1 Volta GPU (half the resources on our Xeon-G6 nodes), you
    would run:</li>
</ul>
<h2 id="submitting-a-simple-serial-batch-job-serial">Submitting a Simple Serial Batch Job {##serial}<a class="headerlink" href="#submitting-a-simple-serial-batch-job-serial" title="Permanent link"></a></h2>
<p>Submitting a batch job to the scheduler is the same for most languages.
This starts by writing a submission script. This script should be a bash
script (it should start with <code>#!/bin/bash</code>) and contain the command(s)
you need to run your code from the command line. It can also contain
scheduler flags at the beginning of the script, or load modules or set
environment variables you need to run your code.</p>
<p>A job submission script for a simple, serial, batch job (for example,
running a python script) looks like this:</p>
<blockquote>
<p><code>#!/bin/bash</code></p>
<p><code># Loading the required module source /etc/profile module load anaconda/2020a</code></p>
<p><code># Run the script python myScript.py</code></p>
</blockquote>
<p>The first line is the <code>#!/bin/bash</code> mentioned earlier. It looks like a
comment, but it isn\'t. This tells the machine how to interpret the
script, that it is a bash script. Lines 3 and 4 demonstrate how to load
a module in a submission script. The final line of the script runs your
code. This should be the command you use to run your code from the
command line, including any input arguments. This example is running a
python script, therefore we have <code>python myScript.py</code>.</p>
<h3 id="submitting-with-llsub">Submitting with LLsub<a class="headerlink" href="#submitting-with-llsub" title="Permanent link"></a></h3>
<p>To submit a simple batch job, you can use the LLsub command:</p>
<blockquote>
<p><code>LLsub myScript.sh</code></p>
</blockquote>
<p>Here <code>myScript.sh</code> can be a job submission script, or could be replaced
by a compiled executable. The <code>LLsub</code> command, with no arguments,
creates a scheduler command with some default options. If your
submission script is <code>myScript.sh</code>, your output file will be
<code>myScript.sh.log-%j</code>, where <code>%j</code> is a unique numeric identifier, the
JobID for your job. The output file is where all the output for your job
gets written. Anything that normally is written to the screen when you
run your code, including any errors or print statements, will be printed
to this file.</p>
<p>When you run this command, the scheduler will find available resources
to launch your job to. Then <code>myScript.sh</code> will run to completion, and
the job will finish when the script is complete.</p>
<h3 id="submitting-with-slurm-scheduler-commands">Submitting with Slurm Scheduler Commands<a class="headerlink" href="#submitting-with-slurm-scheduler-commands" title="Permanent link"></a></h3>
<p>To submit a simple batch job with the same default behavior as LLsub
above, you would run:</p>
<blockquote>
<p><code>sbatch -o myScript.sh.log-%j myScript.sh</code></p>
</blockquote>
<p>Here <code>myScript.sh</code> can be a job submission script, or could be replaced
by a compiled executable. The <code>-o</code> flag states the name of the file
where any output will be written, the <code>%j</code> portion indicates job ID. If
you do not include this flag, any output will be written to
<code>slurm-JOBID.out</code>, which may make it difficult differentiate between job
outputs.</p>
<p>You can also incorporate this flag into your job submission script by
adding lines starting with <code>#SBATCH</code> followed by the flag right after
the first <code>#!/bin/bash</code> line:</p>
<blockquote>
<p><code>#!/bin/bash</code></p>
<p><code># Slurm sbatch options #SBATCH -o myScript.sh.log-%j</code></p>
<p><code># Loading the required module source /etc/profile module load anaconda/2020a</code></p>
<p><code># Run the script python myScript.py</code></p>
</blockquote>
<p>Like <code>#!/bin/bash</code>, these lines starting with <code>#SBATCH</code> look like
comments, but they are not. As you add more flags to specify what
resources your job needs, it becomes easier to specify them in your
submission script, rather than having to type them out at the command
line. If you incorporate Slurm flags in your script like this, you can
submit it by running:</p>
<blockquote>
<p><code>sbatch myScript.sh</code></p>
</blockquote>
<p>When you run these commands, the scheduler will find available resources
to launch your job to. Then <code>myScript.sh</code> will run to completion, and
the job will finish when the script is complete.</p>
<p>Note that when you start adding additional resources you need to make a
choice between using <code>LLsub</code> and <code>sbatch</code>. If you have <code>sbatch</code> options
in your submission script and submit it with <code>LLsub</code>, <code>LLsub</code> will
ignore any additional command line arguments you give it and use those
described in the script.</p>
<h2 id="requesting-additional-resources-with-sbatch-sbatch">Requesting Additional Resources with sbatch {##sbatch}<a class="headerlink" href="#requesting-additional-resources-with-sbatch-sbatch" title="Permanent link"></a></h2>
<p>By default you will be allocated a single core for your job. This is
fine for testing, but usually you\'ll want more than that. For example
you may want:</p>
<ul>
<li><code>Additional cores on multiple nodes (distributed) &lt;#slurm-dist&gt;</code>{.interpreted-text
    role="ref"}</li>
<li><code>Additional cores on the same node (shared memory or threading) &lt;#slurm-shared&gt;</code>{.interpreted-text
    role="ref"}</li>
<li><code>Multiple independent tasks (job array/throughput) &lt;#slurm-jobarray&gt;</code>{.interpreted-text
    role="ref"}</li>
<li><code>Exclusive node(s) &lt;#slurm-exclusive&gt;</code>{.interpreted-text role="ref"}</li>
<li><code>More memory or cores per process/task/worker &lt;#slurm-memcores&gt;</code>{.interpreted-text
    role="ref"}</li>
<li><code>GPUs &lt;#slurm-gpus&gt;</code>{.interpreted-text role="ref"}</li>
</ul>
<p>Here we have listed and will go over some of the more common resource
requests. Most of these you can combine to get what you want. We will
show the lines that you would add to your submission script, but note
that you can also include these options at the command line if you want.</p>
<p>How do you know what you should request? An in-depth discussion on this
is outside the scope of this documentation, but we can provide some
basic guidance. Generally, parallel programs are either implemented to
be distributed or not. Distributed programs can communicate across
different nodes, and so can scale beyond a single node. Programs written
with MPI, for example, would be distributed. Non-Distributed programs
you may see referred to as shared memory or multithreaded. Python\'s
multiprocessing package is a good example of a shared memory library.
Whether your program is Distributed or Shared Memory dictates how you
request additional cores: do they need to be all on the same node, or
can they be on different nodes? You also want to think about what you
are running: if you are running a series of identical independent tasks,
say you are running the same code over a number of files or parameters,
this is referred to as Throughput and can be run in parallel using a Job
Array. (If you are iterating over files like this, and have some
reduction step at the end, take a look at
<code>LLMapReduce &lt;#llmapreduce&gt;</code>{.interpreted-text role="ref"}). Finally,
you may want to think about whether your job could use more than the
default amount of memory, or RAM, and whether it can make use of a GPU.</p>
<h3 id="additional-cores-on-multiple-nodes-slurm-dist">Additional Cores on Multiple Nodes {##slurm-dist}<a class="headerlink" href="#additional-cores-on-multiple-nodes-slurm-dist" title="Permanent link"></a></h3>
<p>The flag to request a certain number of cores that can be on more than
one node is <code>--ntasks</code>, or <code>-n</code> for short. A task is Slurm\'s
terminology for an individual process or worker. For example, to request
4 tasks you can add the following to your submission script:</p>
<blockquote>
<p><code>#SBATCH -n 4</code></p>
</blockquote>
<p>You can control how many nodes these tasks are split onto using the
<code>--nodes</code>, or <code>-N</code>. Your tasks will be split evenly across the nodes you
request. For example, if I were to have the following in my script:</p>
<blockquote>
<p><code>#SBATCH -n 4 #SBATCH -N 2</code></p>
</blockquote>
<p>I would have four tasks on two nodes, two tasks on each node. Specify
the number of nodes like this does not ensure that you have exclusive
access to those nodes. It will by default allocate one core for each
task, so in this case you\'d get a total of four cores, two on each
node. If you need more than one core for each task, take a look at the
<code>cpus-per-task &lt;#slurm-memcores&gt;</code>{.interpreted-text role="ref"} option,
and if you need exclusive access to those nodes see the
<code>exclusive &lt;#slurm-exclusive&gt;</code>{.interpreted-text role="ref"} option.</p>
<h3 id="additional-cores-on-the-same-node-slurm-shared">Additional Cores on the Same Node {##slurm-shared}<a class="headerlink" href="#additional-cores-on-the-same-node-slurm-shared" title="Permanent link"></a></h3>
<p>There are technically two ways to do this. You can use the same options
as requesting tasks on multiple nodes and setting the number of Nodes to
1, say we want four cores:</p>
<blockquote>
<p><code>#SBATCH -n 4 #SBATCH -N 1</code></p>
</blockquote>
<p>Or you can use <code>-c</code>, or the <code>--cpus-per-task</code> option by itself:</p>
<blockquote>
<p><code>#SBATCH -c 4</code></p>
</blockquote>
<p>As far as the number of cores you get, the result will be the same.
You\'ll get the four cores on a single node. There is a bit of a nuance
on how Slurm sees it. The first allocates four tasks all on one node.
The second allocates a single task with four CPUs or cores. You don\'t
need to worry too much about this, choose whichever makes the most sense
to you.</p>
<h3 id="job-arrays-slurm-jobarray">Job Arrays {##slurm-jobarray}<a class="headerlink" href="#job-arrays-slurm-jobarray" title="Permanent link"></a></h3>
<p><strong>NOTE:</strong> We encourage everyone who runs a job array to use LLsub with
Triples mode. See the page <code>job_array_triples</code>{.interpreted-text
role="ref"} to see how to set this up.</p>
<p>A simple way to run the same script or command with different parameters
or on different files in parallel is by using a Job Array. With a Job
Array, the parallelism happens at the Scheduler level and is completely
language agnostic. The best way to use a Job Array is to batch up your
parameters so you have a finite number of tasks each running a set of
parameters, rather than one task for each parameter. In your submission
script you specify numeric indices, corresponding to the number of tasks
that you want running at once. Those indices, or Task IDs are captured
in environment variables, along with the total number of tasks, and
passed into your script. Your script then has the information it needs
to split up the work among tasks. This process is described in the
<a href="https://github.com/llsc-supercloud/teaching-examples">Teaching
Examples</a> github
repository, with examples in
<a href="https://github.com/llsc-supercloud/teaching-examples/tree/master/Julia/word_count/JobArray">Julia</a>
and
<a href="https://github.com/llsc-supercloud/teaching-examples/tree/master/Python/word_count/JobArray">Python</a>.</p>
<p>First you want to take a look at your code. Code that can be submitted
as a Job Array usually has one big for loop. If you are iterating over
multiple parameters or files, and have nested for loops, you\'ll first
want to enumerate all the combinations of what you are iterating over so
you have one big loop. Then you want to add a few lines to your code to
take in two arguments, the Task ID and the number of tasks, use those
numbers to split up the thing you are iterating over. For example, I
might have a list of filenames, <code>fnames</code>. In python I would add:</p>
<blockquote>
<p><code># Grab the arguments that are passed in my_task_id = int(sys.argv[1]) num_tasks = int(sys.argv[2])</code></p>
<p><code># Assign indices to this process/task my_fnames = fnames[my_task_id-1:len(fnames):num_tasks]</code></p>
<p><code>for f in my_fnames: ...</code></p>
</blockquote>
<p>Notice that I am iterating over <code>my_fnames</code>, which is a subset of the
full list of filenames determined by the task ID and number of tasks.
This subset will be different for each task in the array. Note that the
third line of code will be different for languages with arrays that
start at index 1 (see the <a href="https://github.com/llsc-supercloud/teaching-examples/tree/master/Julia/word_count/JobArray">Julia Job
Array</a>
code for an example of this).</p>
<p>The submission script will look like this:</p>
<blockquote>
<p><code>#!/bin/bash</code></p>
<p><code>#SBATCH -o myScript.sh.log-%j-%a #SBATCH -a 1-4</code></p>
<p><code>python top5each.py $SLURM_ARRAY_TASK_ID $SLURM_ARRAY_TASK_COUNT</code></p>
</blockquote>
<p>The <code>-a</code> (or <code>--array</code>) option is where you specify your array indices,
or task IDs. Here I am creating an array with four tasks by specifying 1
\"through\" 4. When the scheduler starts your job, it will start up four
independent tasks, each will run this script, and each will have
<code>#SLURM_ARRAY_TASK_ID</code> set to its task ID. Similarly,
<code>$SLURM_ARRAY_TASK_COUNT</code> will be set to the total number of tasks, in
this case 4.</p>
<p>You may have noticed that there is an additional <code>%a</code> in the output file
name. There will be one output file for each task in the array, and the
<code>%a</code> puts the task ID on at the end of the filename, so you know which
file goes with which task.</p>
<p>By default you will get one core for each task in the array. If you need
more than one core for each task, take a look at the
<code>cpus-per-task &lt;#slurm-memcores&gt;</code>{.interpreted-text role="ref"} option,
and if you need to add a GPU to each task, check out the the
<code>GPUs &lt;#slurm-gpus&gt;</code>{.interpreted-text role="ref"} section.</p>
<h3 id="exclusive-nodes-slurm-exclusive">Exclusive Nodes {##slurm-exclusive}<a class="headerlink" href="#exclusive-nodes-slurm-exclusive" title="Permanent link"></a></h3>
<p>Requesting an exclusive node ensures that there will be no other users
on the node with you. You might want to do this when you know you need
to make use of the full node, when you are running performance tests, or
when you think your program might affect other users. There is some
software that have not been designed for a shared HPC environment, and
so use all the cores on the node, whether you have allocated them or
not. You can look through their documentation to see if there is a way
to limit the number of cores it uses, or you can request an exclusive
node. Another situation where you might affect other users is when you
don\'t yet know what resources your code requires. For these first few
runs it makes sense to request an exclusive node, and then look at the
resources that your job used, and request those resources in the future.</p>
<p>To request an exclusive node or nodes, you can add the following option:</p>
<blockquote>
<p><code>#SBATCH --exclusive</code></p>
</blockquote>
<p>This will ensure that wherever the tasks in your job land, those nodes
will be exclusive. If you have four tasks, for example, specified with
either <code>-n</code> (<code>--ntasks</code>) or in a job array, and those four tasks fall on
the same node, you will get that one node exclusively. It will not force
each task onto its own exclusive node without adding other options.</p>
<h3 id="adding-more-memory-or-cores-per-task-slurm-memcores">Adding More Memory or Cores per Task {##slurm-memcores}<a class="headerlink" href="#adding-more-memory-or-cores-per-task-slurm-memcores" title="Permanent link"></a></h3>
<p>You can ensure that each task has more than one core or the default
amount of memory the same way. By default, each core gets its fair share
of the RAM on the node, calculated by the total amount of memory on the
node divided by the number of cores. See the
<code>systems_and_software</code>{.interpreted-text role="ref"} page for a list of
the amount of RAM, number of cores, and RAM per core for each resource
type. For example, with the Xeon-P8 nodes, they have 192 GB of RAM and
48 cores, so each core gets 4 GB of RAM. Therefore, the way to request
more memory is to request more cores. Even if you are not using the
additional core(s), you are using their memory. The way to do this is
using the <code>--cpus-per-task</code>, or <code>-c</code> option. Say I know each task in my
job will use about 20 GB of memory, with the Xeon-P8 nodes above, I\'d
want to request five cores for each task:</p>
<blockquote>
<p><code>#SBATCH -c 5</code></p>
</blockquote>
<p>This works nicely with both the <code>-n</code> (<code>--ntasks</code>) and <code>-a</code> (<code>--array</code>)
options. As the flag name implies, you will get 5 cpu cores for every
task in your job. If you are already using the <code>-c</code> option for a shared
memory or threaded job, you can either use the <code>-n</code> and <code>-N 1</code>
alternative and save <code>-c</code> for adding additional memory, or you can
increase what you put for <code>-c</code>. For example, if I know I\'m going to use
4 cores in my code, but each will need 20 GB of RAM, I can request a
total of 4*5 = 20 cores.</p>
<p>How do you know how much memory your job needs? You can find out how
much memory a job used after the job is completed. You can run your job
long enough to get an idea of the memory requirement first in [exclusive
\&lt;#slurm-exclusive>]{.title-ref} mode so your job can have access to
the maximum amount of memory. Then you can use the <code>sacct</code> slurm command
to get the memory used:</p>
<blockquote>
<p><code>sacct -j JOBID -o JobID,JobName,State,AllocCPUS,MaxRSS,MaxVMSize --units=G</code></p>
</blockquote>
<p>where JOBID is your job ID. State shows the job status, keep in mind
that the memory numbers are only accurate for jobs that are no longer
running, and AllocCPUS is the number of CPU cores that were allocated to
the job. MaxRSS is the maximum resident memory (maximum memory
footprint) used by each job array job, while MaxVMSize is the maximum
memory that was requested by the process (the peak memory usage). In
other words, MaxVMSize is the high-watermark of memory that was
allocated by the process, regardless of whether it was used or not. The
MaxRSS size is the maximum physical memory that was actually used.</p>
<p>If the MaxVMSize value is larger than the per-slot/core memory limit for
the compute node (again, check the
<code>systems_and_software</code>{.interpreted-text role="ref"} page to get this
for the resource type you are requesting), you will have to request
additional memory for your job.</p>
<p>This formatting for the accounting data prints out a number of memory
datapoints for the job. They are all described in the <a href="https://slurm.schedmd.com/sacct.html">sacct man
page</a>.</p>
<h3 id="reqesting-gpus-slurm-gpus">Reqesting GPUs {##slurm-gpus}<a class="headerlink" href="#reqesting-gpus-slurm-gpus" title="Permanent link"></a></h3>
<p>Some code can be accelerated by adding a GPU, or Graphical Processing
Unit. GPUs are specialized hardware originally developed for rendering
the graphics you see on your computer screen, but have been found to be
very fast at doing certain operations and have therefore been adopted as
an accelerator. They are frequently used in Machine Learning libraries,
but are increasingly used in other software. You can also write your own
GPU code using CUDA.</p>
<p>Before requesting a GPU, you should verify that the software, libraries,
or code that you are using can make use of a GPU, or multiple GPUs. The
Machine Learning packages available in our anaconda modules should all
be able to take advantage of GPUs. To request a single GPU, add the
following line to your submission script:</p>
<blockquote>
<p><code>#SBATCH --gres=gpu:volta:1</code></p>
</blockquote>
<p>This flag will give you a single GPU. For multi-node jobs, it\'ll give
you a single GPU for every node you end up on, and will give you a
single GPU for every task in a Job Array. If your code can make use of
multiple GPUs, you can set this to 2 instead of 1, and that will give
you 2 GPUs for each node or Job Array task.</p>
<p>Note that only certain operations are being done on the GPU, your job
will still most likely run best given a number of CPU cores as well. If
you are not sure how many to request, if you request 1 GPU, ask for 20
CPUs (half of the CPUs), if you request 2 GPUs, you can ask for all of
the CPUs. You can check the current CPU and GPU counts for each node on
our <code>systems_and_software</code>{.interpreted-text role="ref"} page.</p>
<h2 id="requesting-additional-resources-with-llsub-llsub">Requesting Additional Resources with LLsub {##llsub}<a class="headerlink" href="#requesting-additional-resources-with-llsub-llsub" title="Permanent link"></a></h2>
<p>By default you will be allocated a single core for your job. This is
fine for testing, but usually you\'ll want more than that. For example
you may want:</p>
<ul>
<li><code>Additional cores on the same node (shared memory or
    threading) &lt;#llsub-shared&gt;</code>{.interpreted-text role="ref"}</li>
<li><code>Multiple independent tasks (job
    array/throughput) &lt;#llsub-jobarray&gt;</code>{.interpreted-text role="ref"}</li>
<li><code>More memory or cores per process/task/worker &lt;#llsub-memcores&gt;</code>{.interpreted-text
    role="ref"}</li>
<li><code>GPUs &lt;#llsub-gpus&gt;</code>{.interpreted-text role="ref"}</li>
</ul>
<p>Here we have listed and will go over some of the more common resource
requests. Most of these you can combine to get what you want. We will
show the lines that you would add to your submission script, but note
that you can also include these options at the command line if you want.</p>
<p>How do you know what you should request? An in-depth discussion on this
is outside the scope of this documentation, but we can provide some
basic guidance. Generally, parallel programs are either implemented to
be distributed or not. Distributed programs can communicate across
different nodes, and so can scale beyond a single node. Programs written
with MPI, for example, would be distributed. Non-Distributed programs
you may see referred to as shared memory or multithreaded. Python\'s
multiprocessing package is a good example of a shared memory library.
Whether your program is Distributed or Shared Memory dictates how you
request additional cores: do they need to be all on the same node, or
can they be on different nodes? You also want to think about what you
are running: if you are running a series of identical independent tasks,
say you are running the same code over a number of files or parameters,
this is referred to as Throughput and can be run in parallel using a Job
Array. (If you are iterating over files like this, and have some
reduction step at the end, take a look at
<code>LLMapReduce &lt;#llmapreduce&gt;</code>{.interpreted-text role="ref"}). Finally,
you may want to think about whether your job could use more than the
default amount of memory, or RAM, and whether it can make use of a GPU.</p>
<p>If you are submitting your job with LLsub, you should be aware of its
behavior. If you have any Slurm options in your submission script (any
lines starting with <code>#SBATCH</code>) LLsub will ingore any command line
arguments you give it and only use those you specify in your script. You
can still submit this script with LLsub, but it won\'t add any extra
command line arguments you pass it.</p>
<h3 id="additional-cores-on-the-same-nodeadditional-cores-on-the-same-node-1-llsub-shared">Additional Cores on the Same Node[]{#additional-cores-on-the-same-node-1} {##llsub-shared}<a class="headerlink" href="#additional-cores-on-the-same-nodeadditional-cores-on-the-same-node-1-llsub-shared" title="Permanent link"></a></h3>
<p>Libraries that use shared memory or threading to handle parallelism
require that all cores be on the same node. In this case you are
constrained to the number of cores on a single machine. Check the
<code>systems_and_software</code>{.interpreted-text role="ref"} page to see the
number of cores available on the current hardware.</p>
<p>To request multiple cores on the same node for your job you can use the
<code>-s</code> option in <code>LLsub</code>. This stands for \"slots\". For example, if I am
running a job and I\'d like to allocate 4 cores to it, I would run:</p>
<blockquote>
<p><code>LLsub myScript.sh -s 4</code></p>
</blockquote>
<h3 id="job-array-llsub-jobarray">Job Array {##llsub-jobarray}<a class="headerlink" href="#job-array-llsub-jobarray" title="Permanent link"></a></h3>
<p>Take a look at the <code>Slurm instructions above for how to set up a Job
Array &lt;#slurm-jobarray&gt;</code>{.interpreted-text role="ref"}. You\'ll still
set up your code the same, and pass the two environment variables
<code>#SLURM_ARRAY_TASK_ID</code> and <code>$SLURM_ARRAY_TASK_COUNT</code> into your script.
When you submit, rather than adding <code>#SBATCH</code> lines to your submission
script, you would use the <code>-t</code> option:</p>
<blockquote>
<p><code>LLsub myScript.sh -t 1-4</code></p>
</blockquote>
<p>If you need more cores or memory for each task, you can add the <code>-s</code>
option as described <code>below &lt;#llsub-memcores&gt;</code>{.interpreted-text
role="ref"}.</p>
<h3 id="adding-more-memory-or-cores-llsub-memcores">Adding More Memory or Cores {##llsub-memcores}<a class="headerlink" href="#adding-more-memory-or-cores-llsub-memcores" title="Permanent link"></a></h3>
<p>If you anticipate that your job will use more than \~4 GB of RAM, you
may need to allocate more resources for your job. You can be sure your
job has enough memory to run by allocating more slots, or cores, to each
task or process in your job. Each core gets its fair share of the RAM on
the node, calculated by the total amount of memory on the node divided
by the number of cores. See the <code>systems_and_software</code>{.interpreted-text
role="ref"} page for a list of the amount of RAM, number of cores, and
RAM per core for each resource type. For example, the Xeon-P8 nodes have
192 GB of RAM and 48 cores, so each core gets 4 GB of RAM. Therefore,
the way to request more memory is to request more cores. Even if you are
not using the additional core(s), you are using their memory. The way to
do with LLsub is the <code>-s</code> (for slots) option. Say I know each task in my
job will use about 20 GB of memory, with the Xeon-P8 nodes above, I\'d
want to request five cores for each task:</p>
<blockquote>
<p><code>LLsub myScript.sh -s 5</code></p>
</blockquote>
<p>If you are already using the <code>-s</code> option for a shared memory or threaded
job, you should increase what you put for <code>-s</code>. For example, if I know
I\'m going to use 4 cores in my code, but each will need 20 GB of RAM, I
can reqest a total of 4*5 = 20 cores:</p>
<blockquote>
<p><code>LLsub myScript.sh -s 20</code></p>
</blockquote>
<p>How do you know how much memory your job needs? You can find out how
much memory a job used after the job is completed. You can run your job
long enough to get an idea of the memory requirement first (you can
request the maximum number of cores per node for this step). Then you
can use the <code>sacct</code> slurm command to get the memory used:</p>
<blockquote>
<p><code>sacct -j JOBID -o</code>JobID,JobName,State,AllocCPUS,MaxRSS,MaxVMSize
--units=G</p>
</blockquote>
<p>where JOBID is your job ID. State shows the job status, keep in mind
that the memory numbers are only accurate for jobs that are no longer
running, and AllocCPUS is the number of CPU cores that were allocated to
the job. MaxRSS is the maximum resident memory (maximum memory
footprint) used by each job array job, while MaxVMSize is the maximum
memory that was requested by the process (the peak memory usage). In
other words, MaxVMSize is the high-watermark of memory that was
allocated by the process, regardless of whether it was used or not. The
MaxRSS size is the maximum physical memory that was actually used.</p>
<p>If the MaxVMSize value is larger than the per-slot/core memory limit for
the compute node (again, check the
<code>systems_and_software</code>{.interpreted-text role="ref"} page to get this
for the resource type you are requesting), you will have to request
additional memory for your job.</p>
<p>This formatting for the accounting data prints out a number of memory
data points for the job. They are all described in the <a href="https://slurm.schedmd.com/sacct.html">sacct man
page</a>.</p>
<h3 id="requesting-gpus-llsub-gpus">Requesting GPUs {##llsub-gpus}<a class="headerlink" href="#requesting-gpus-llsub-gpus" title="Permanent link"></a></h3>
<p>Some code can be accelerated by adding a GPU, or Graphical Processing
Unit. GPUs are specialized hardware originally developed for rendering
the graphics you see on your computer screen, but have been found to be
very fast at doing certain operations and have therefore been adopted as
an accelerator. They are frequently used in Machine Learning libraries,
but are increasingly used in other software. You can also write your own
GPU code using CUDA.</p>
<p>Before requesting a GPU, you should verify that the software, libraries,
or code that you are using can make use of a GPU, or multiple GPUs. The
Machine Learning packages available in our anaconda modules should all
be able to take advantage of GPUs. To request a single GPU, use the
following command:</p>
<blockquote>
<p><code>LLsub myScript.sh -g volta:1</code></p>
</blockquote>
<p>This flag will give you a single GPU. For multi-node jobs, it\'ll give
you a single GPU for every node you end up on, and will give you a
single GPU for every task in a Job Array. If your code can make use of
multiple GPUs, you can set this to 2 instead of 1, and that will give
you 2 GPUs for each node or Job Array task.</p>
<p>Note that only certain operations are being done on the GPU, your job
will still most likely run best given a number of CPU cores as well. If
you are not sure how many to request, if you request 1 GPU, ask for 20
CPUs (half of the CPUs), if you request 2 GPUs, you can ask for all of
the CPUs. You can check the current CPU and GPU counts for each node on
our <code>systems_and_software</code>{.interpreted-text role="ref"} page. To
request 20 cores and 1 GPU, run:</p>
<blockquote>
<p><code>LLsub myScript.sh -s 20 -g volta:1</code></p>
</blockquote>
<h2 id="llmapreduce-llmapreduce">LLMapReduce {##llmapreduce}<a class="headerlink" href="#llmapreduce-llmapreduce" title="Permanent link"></a></h2>
<p>The LLMapReduce command scans the user-specified input directory and
translates each individual file as a computing task for the
user-specified application. Then, the computing tasks will be submitted
to scheduler for processing. If needed, the results can be
post-processed by setting up a user-specified reduce task, which is
dependent on the mapping task results. The reduce task will wait until
all the results become available.</p>
<p>You can view the most up-to-date options for the LLMapReduce command by
running the command LLMapReduce -h. You can see examples of how to use
LLMapReduce jobs in /usr/local/examples directory on the Supercloud
system nodes. Some of these may be in the <code>examples</code> directory in your
home directory. You can copy any that are missing from
<code>/usr/local/examples</code> to your home directory. We also have an example in
the <a href="https://github.com/llsc-supercloud/teaching-examples">Teaching
Examples</a> github
repository, with examples in
<a href="https://github.com/llsc-supercloud/teaching-examples/tree/master/Julia/word_count/LLMapReduce">Julia</a>
and
<a href="https://github.com/llsc-supercloud/teaching-examples/tree/master/Python/word_count/LLMapReduce">Python</a>.
These examples are also available in the bwedx shared group directory
and can be copied to your home directory from there.</p>
<p>LLMapReduce can work with any programs and we have a couple of examples
for Java, Matlab, Julia, and Python. By default, it cleans up the
temporary directory, .MAPRED.PID. However, there is an option to keep
(--keep true) the temporary directory if you want it for debugging. The
current version also supports a nested LLMapReduce call.</p>
<h2 id="matlaboctave-tools-matlab">Matlab/Octave Tools {##matlab}<a class="headerlink" href="#matlaboctave-tools-matlab" title="Permanent link"></a></h2>
<h3 id="pmatlab">pMatlab<a class="headerlink" href="#pmatlab" title="Permanent link"></a></h3>
<p>pMatlab was created at MIT Lincoln Laboratory to provide easy access to
parallel computing for engineers and scientists using the MATLAB(R)
language. pMatlab provides the interfaces to the communication libraries
necessary for distributed computation. In addition to MATLAB(R), pMatlab
works seamlessly with Octave, and open source Matlab toolkit.</p>
<p>MATLAB(R) is the primary development language used by Laboratory staff,
and thus the place to start when developing an infrastructure aimed at
removing the traditional hurdles associated with parallel computing. In
an effort to develop a tool that will enable the researcher to
seamlessly move from desktop (serial) to parallel computing, pMatlab has
adopted the use of Global Array Semantics. Global Array Semantics is a
parallel programming model in which the programmer views an array as a
single global array rather than multiple subarrays located on different
processors. The ability to access and manipulate related data
distributed across processors as a single array more closely matches the
serial programming model than the traditional parallel approach, which
requires keeping track of which data resides on any given individual
processor.</p>
<p>Along with global array semantics, pMatlab uses the message-passing
capabilities of MatlabMPI to provide a global array interface to
MATLAB(R)) programmers. The ultimate goal of pMatlab is to move beyond
basic messaging (and its inherent programming complexity) towards higher
level parallel data structures and functions, allowing MATLAB(R)) users
to parallelize their existing programs by simply changing and adding a
few lines.</p>
<p>Any pMatlab code can be run on the MIT Supercloud using standard pMatlab
submission commands. The Practical High Performance Computing course on
our online course platform provides a very good introduction for how to
use pMatlab. There is also an examples directory in your home directory
that provides several examples. The Param_Sweep example is a good place
to start. There is an in-depth explanation of this example in the
<a href="https://github.com/llsc-supercloud/teaching-examples/tree/master/Matlab-Octave/Param_Sweep">Teaching
Examples</a>
github repository.</p>
<p>If you anticipate that your job will use more than \~10 GB of RAM, you
need to allocated more resources for your job. You can be sure your job
has enough memory to run by allocating more slots, or cores, to each
task or process in your job. For example, our nodes have 40 cores and
384 GB of RAM, therefore each core represents about 10 GB. So if your
job needs \~20 GB, allocate two cores or slots per process. Doing so
will ensure your job will not fail due running out of memory, and not
interfere with someone else\'s job.</p>
<p>To do this with pMatlab, you can add the following line to your run
script, before you the <code>eval(pRUN(...))</code> command:</p>
<blockquote>
<p><code>setenv('GRIDMATLAB_MT_SLOTS','2')</code></p>
</blockquote>
<h3 id="submitting-with-llsub-or-sbatch">Submitting with LLsub or Sbatch<a class="headerlink" href="#submitting-with-llsub-or-sbatch" title="Permanent link"></a></h3>
<p>You can always submit a Matlab(R) script with a submission script
through sbatch or LLsub. The basic submission script looks like this:</p>
<blockquote>
<p><code>#!/bin/bash</code></p>
<p><code># Run the script matlab -nodisplay -r "myScript; exit"</code></p>
</blockquote>
<p>Where <code>myScript</code> is the name of the Matlab script that you want to run.
When running a Matlab script through a submission script, you do need to
specify that Matlab should exit after it runs your code. Otherwise it
will continue to run, waiting for you to give it the next command.</p>
<h3 id="launchfunctionongrid-and-launchparforongrid">LaunchFunctionOnGrid and LaunchParforOnGrid<a class="headerlink" href="#launchfunctionongrid-and-launchparforongrid" title="Permanent link"></a></h3>
<p>If you want to launch your serial MATLAB scripts or functions on LLSC
systems, you can use the <code>LaunchFunctionOnGrid()</code> function. You can
execute your code without any modification (if it is written for a Linux
environment) as a batch job. Its usage, in Matlab, is as follows:</p>
<blockquote>
<p><code>launch_status = LaunchFunctionOnGrid(m_file) launch_status = LaunchFunctionOnGrid(m_file,variables)</code></p>
</blockquote>
<p>Where m_file is a string that specifies the script or function to be
run, and variables is the list of variables that are being passed in.
Note that variables must be variables, not constants.</p>
<p>If you want to launch your MATLAB scripts or functions that call the
<code>parfor()</code> function on LLSC systems, you can use the
<code>LaunchParforOnGrid()</code> function. You can execute your code without any
modification (if it is written for a Linux environment) as a batch job.
While <code>LaunchParforOnGrid()</code> will work functionally, it has significant
limitations in performance, both at the node level and the cluster
level; it might be better to use pMatlab instead. To use the
<code>LaunchParforOnGrid()</code> function in MATLAB:</p>
<blockquote>
<p><code>launch_status = LaunchParforOnGrid(m_file) launch_status = LaunchParforOnGrid(m_file,variables)</code></p>
</blockquote>
<p>Where m_file is a string that specifies the script or function to be
run, and variables is the list of variables that are being passed in.
Note that variables must be variables, not constants.</p>
<p>If you anticipate that your job will use more than \~10 GB of RAM, you
need to allocated more resources for your job. You can be sure your job
has enough memory to run by allocating more slots, or cores, to each
task or process in your job. For example, our nodes have 40 cores and
384 GB of RAM, therefore each core represents about 10 GB. So if your
job needs \~20 GB, allocate two cores or slots per process. Doing so
will ensure your job will not fail due running out of memory, and not
interfere with another person\'s job.</p>
<p>To do this with LaunchFunctionOnGrid or LaunchParforOnGrid, you can add
the following line to your run script, before you use the
<code>LaunchFunctionOnGrid()</code> or <code>LaunchParforOnGrid()</code> command:</p>
<blockquote>
<p><code>setenv('GRIDMATLAB_MT_SLOTS','2')</code></p>
</blockquote>
<h2 id="triples-mode-triples">Triples Mode {##triples}<a class="headerlink" href="#triples-mode-triples" title="Permanent link"></a></h2>
<p>Triples mode is a way to launch pMatlab,
<code>LLsub Job Array &lt;job_array_triples&gt;</code>{.interpreted-text role="ref"}, and
LLMapReduce jobs that gives you better performance and more flexibility
to manage memory and threads. Unless you are requesting a small number
of cores for your job, we highly encourage you to migrate to this model.</p>
<p>With triples mode, you specify the resources for your job by providing 3
parameters:</p>
<blockquote>
<p><code>[Nodes NPPN NThreads]</code></p>
</blockquote>
<p>where</p>
<blockquote>
<p>| <code>Nodes</code>is number of compute nodes
| <code>NPPN</code>is number of processes per node
| <code>NThreads</code>is number of threads per process (default is 1)</p>
</blockquote>
<p>With triples mode your job will have exclusive use of each of the nodes
that you request, so the total number of cores consumed against your
allocation will be Nodes * 40.</p>
<h3 id="llsub">LLsub<a class="headerlink" href="#llsub" title="Permanent link"></a></h3>
<p>A brief introduction to LLsub is provided
<code>above &lt;#llsub-jobarray&gt;</code>{.interpreted-text role="ref"}. To use triples
mode to launch LLsub job on Supercloud, run as follows:</p>
<blockquote>
<p><code>LLsub ./submit.sh [Nodes,NPPN,NThreads]</code></p>
</blockquote>
<p>A more in-depth guide on how to convert an existing Job Array to an
LLsub Triples submission is provided on the page
<code>job_array_triples</code>{.interpreted-text role="ref"}.</p>
<h3 id="llmapreduce">LLMapReduce<a class="headerlink" href="#llmapreduce" title="Permanent link"></a></h3>
<p>A brief introduction to LLMapReduce is provided
<code>above &lt;#llmapreduce&gt;</code>{.interpreted-text role="ref"}. To use triples
mode to launch your LLMapReduce job on Supercloud, use the --np option
with the triple as its parameter, as follows:</p>
<blockquote>
<p><code>--np=[Nodes,NPPN,NThreads]</code></p>
</blockquote>
<h3 id="pmatlab_1">pMatlab<a class="headerlink" href="#pmatlab_1" title="Permanent link"></a></h3>
<p>A brief introduction to pMatlab is provided
<code>above &lt;#matlab&gt;</code>{.interpreted-text role="ref"}. To use triples mode to
launch your pMatlab job on Supercloud, you use the pRUN() function. Its
usage, in Matlab, is as follows:</p>
<blockquote>
<p><code>eval(pRUN('mfile', [Nodes NPPN OMP_NUM_THREADS], 'grid'))</code></p>
</blockquote>
<h3 id="triples-mode-tuning-tuning">Triples Mode Tuning {##tuning}<a class="headerlink" href="#triples-mode-tuning-tuning" title="Permanent link"></a></h3>
<p>Triples mode tuning provides greater efficiency by allowing you to
better tune your resource requests to your application. This one-time
tuning process typically takes \~1 hour:</p>
<ol>
<li>Instrument your code to print a rate (work/time) giving a sense of
    the speed from a \~1 minute run.</li>
<li>Determine best number of threads (<code>NThreadsBest</code>) by examining rate
    from runs with varying numbers of threads:    
    <code>[1,1,1], [1,1,2], [1,1,4]</code>, ...  </li>
<li>Determine best number of processes per node (<code>NPPNbest</code>) by
    examining rate from runs with varying numbers of processes:    
    <code>[1,1,NThreadsBest], [1,2,NThreadsBest], [1,4,NThreadsBest]</code>, ...  </li>
<li>Determine best number of nodes (<code>NodesBest</code>) by examining rate from
    runs of with varying numbers of nodes:    
    <code>[1,NPPNbest,NThreadsBest], [2,NPPNbest NThreadsBest], [4,NPPNbest NThreadsBest]</code>,
    ...  </li>
<li>Run your production jobs using [NodesBest  NPPNbest  NThreadsBest]</li>
</ol>
<p>You could tune <code>NPPN</code> first, then <code>NThreads</code>. This would be a better
approach if you are memory bound. You can find the max <code>NPPN</code> that will
fit, then keep increasing <code>NThreads</code> until you stop getting more
performance.</p>
<p>\"Good\" <code>NPPN</code> values for Xeon-P8: 1, 2, 4, 8, 16, 24, 32, 48</p>
<p>\"Good\" <code>NPPN</code> values for Xeon-G6: 1, 2, 4, 8, 16, 20, 32, 40</p>
<p>Triples mode tuning results in a \~2x increase efficiency for many
users.</p>
<p>Once the best settings have been found, they can be reused as long as
the code remains roughly similar. Recording the rates from the above
process can often result in a publishable <a href="http://www.ieee-hpec.org/">IEEE
HPEC</a> paper. We are happy to work with you to
guide you through this tuning process.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../../monitoring-system-and-jobs/" class="btn btn-neutral float-left" title="Monintoring System and Job Status"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../job-array-triples/" class="btn btn-neutral float-right" title="Job Array Triples">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../../monitoring-system-and-jobs/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../job-array-triples/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../../..';</script>
    <script src="../../../js/theme_extra.js" defer></script>
    <script src="../../../js/theme.js" defer></script>
      <script src="../../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
